## The function 'makeCacheMatrix' takes as argument an object (here an invertible matrix) on which one wishes to perform a computation
## (here compute the inverse of a matrix) and generates a "container" together with the facilities of setting,
## storing and retrieving the following values:
## i) the value of an object on which one wants to perform a (potentialy expensive) computation
## ii) the result of the computation
## This "container" takes the form of a list of 4 functions allowing to set/get the values of the object as well as
## the result of the computation.
##
## The function 'cacheSolve' takes as an argument a "container" generated by 'makeCacheMatrix' and
## performs a given computation (and stores it into the container) only it was not already done before.



## This function takes an invertible matrix as an argument and returns an "extended matrix"
## consisting of a list of 4 functions allowing to:
## i) set the value of the matrix
## ii) get the value of the matrix
## iii) set the value of its inverse
## iv) get the value of its inverse
makeCacheMatrix <- function(x = matrix()) {
  inv <- NULL
  set <- function(y) {
    x <<- y
    inv <<- NULL
  }
  get <- function() x
  setinverse <- function(inverse) inv <<- inverse
  getinverse <- function() inv
  list(set = set, get = get,
       setinverse = setinverse,
       getinverse = getinverse)
}


## This function takes as argument the output of 'makeCacheMatrix'. It checks if the
## relevant computation (here computing the inverse of a matrix) was already done for 
## the matrix passed as argument to 'makeCacheMatrix'. if not, it performs the computation and stores
## the result in the cache using the "container" generated by 'makeCacheMatrix'.
## If yes, it simply retrieves the already stored value in cache.
cacheSolve <- function(x) {
        
  inv <- x$getinverse()
  if(!is.null(inv)) {
    message("getting cached data")
    return(inv)
  }
  data <- x$get()
  inv <- solve(data)
  x$setinverse(inv)
  inv
}
